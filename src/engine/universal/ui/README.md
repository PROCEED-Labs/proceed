# Development of the Graphical User Interface for the PROCEED Engine

## Introduction

The PROCEED Engine offers a UI to work on/with the processes or the Engine itself. This is usually used for the _Tasklist_: a list where a user can work on the tasks which he gets assigned during the process execution. But the UI can also be used for configuring and monitoring the Engine.

## Code Structure and Background

The offered UI is a web page. More exactly, it is a single page application (SPA) with multiple "tabs" - the so-called _display items_.

The web page is offered via one of two methods:

- it is either served via an internal webserver on the Engine (with `HTTP GET http://<engine-ip>:33029/`, mainly used on the Node.js implementation) OR
- it is directly inserted into the WebView component, which happens if the Universal Part of the Engine is executed inside a browser (this is the case for Android and iOS)

In the former case, all data retrieval needs to be done via REST Endpoints, in the latter case the data can directly be requested from the modules of the Universal Part. Implementation-wise there is no such difference, since we created a helper object (`PROCEED_DATA`) which abstracts this differentiation - more on this later.

In general, in `./module.js` every display item is added to the final SPA.
These items must be a subclass of the type `DisplayItem` (found in `./src/display-item.js`).
They are embedded as _iFrames_ in the SPA.
A concrete display item:

- must call the constructor of the parent type `DisplayItem` (with `super()`) to set a name of the tab and an internal _id_ (aka. key)
- must have the `content` property, which contains the HTML/CSS/JS in a minified and packaged form as a string (generated by webpack, explained later)
- defines the communication with the PROCEED Engine to get all the necessary data (via overriding `getEndpoints()` and implementing the data retrieval functionality in own functions)

You can find examples of display items in `./src/display-items/<displayItemName>/<Name>-DisplayItem.js`. For example, `./src/display-items/configuration/Configuration-DisplayItem.js`. The rest of the files in the display item folders are for development and are not used in the final, productive version of the Engine.

All display items are added to the UI via `addDisplayItem()` inside `./module.js`. This function comes from the `./src/ui.js` object, which defines helper functions for creating the SPA and it defines the surrounding layout (in `./src/uiHTML.js`, it is mainly the header part of the SPA).

## Development

0. On the command line, navigate into the ui folder: `cd ./src/engine/universal/ui`
1. In order to develop the HTML, CSS, and JS of the new display item, you should create a _display-item_ directory under `./src/display-items`. Therefore, it is recommended that you copy and rename an existing folder (like _configuration_, _tasklist_ or _logging_), so that you already have a starting point for development.

   - in general, you probably need at least one HTML file called `index.html`, a JavaScript file called `index.js` and a css file with your stylesheet (name not important). Of course there can be more files, but they need to be `import`ed properly (usually in your `index.js` file)

2. Rename the display item in the folder to , edit the `super()` method in the file with the new name + id, add the new display item in `./module.js` via the `addDisplayItem()` method and test the PROCEED Engine (`yarn dev`), if it shows the new Item (of course with the old content if you haven't modified the `content` property).

3. Add the data retrieval methods you need for the new display item by modifying `getEndpoints()` in `<NewName>-DisplayItem.js` and implement the functionality. See later.

4. Add two new `scripts` inside `./ui/package.json` to develop and build the new display item. Therefore copy the existing command for another display item and modify the `TARGET` with your created folder name.

   - this instructs webpack to start a development server and to build your final minified, packaged files by looking for the _index_ files into the given folder.

5. By running your new development command, i.e. `yarn dev-<displayItemName>`, you start a development server on port `9000` for the HTML/CSS/JS files in the new directory. So, you can see your development progress via the browser.

   - if you want to retrieve data from the engine during development, this is not enough. Therefore, you can either define local mock functions (aka `window.PROCEED_DATA`) or set the `src` attribute of the iFrame in the `UI` module to `http://localhost:9000` to load the dev-server. This is done by temporarily removing the `/* DEV` comment in the `script()` method in `./src/uiHTML.js`. Then you need to start the PROCEED Engine via `yarn dev` (in the root directory). Attention: For the latter method you already need to have a productive DisplayItem included in `./module.js` or else the necessary endpoints will not be available.

6. Once the display item's content is ready for production you can run your new build command, i.e. `yarn build-<displayItemName>`. This will use webpack to bundle all files into one final HTML file inside `./src/display-items/<new-display-item-folder>/dist/`. Now, you need to copy this condensed HTML/CSS/JS string from the generated txt file `template.txt` into the `content` variable of your `DisplayItem` subclass, i.e. `<NewName>-DisplayItem.js`. You have finished the development and can start the Engine.

   - you may wonder why not directly copying the content from the generated file `.../dist/index.html`) into the template string: this will most likely cause syntax errors due to not properly escaped characters. For that reason the build command will also create the properly escaped txt file.

### Communication to the Engine via PROCEED_DATA

One of the main things to achieve is the communication of the DisplayItem with the PROCEED engine, e.g. to get the current User Task or transmit the results of a User Task.
This communication can be complicated because the UI should run in two environments: 1. in a WebView (Android, iOS and Browser Engine), and 2. in a Web Page offered by a _Web Server_ running on the Node Engine (Win, Linux, MacOS). So, two different communication technologies needs to be implemented for either environments.

To reduce this challenge, a variable is injected into the context of the DisplayItem: `window.PROCEED_DATA`. With this variable you can access a predefined API (methods: _get_ and _post_) to communicate with the PROCEED Engine. Therefore, you need to override the `getEndpoints()` method (you override the method from the extended class `DisplayItem`) to define the needed API for the new DisplayItem, e.g. `'/api/userTask': { get: this.getUserTask.bind(this), post: this.postUserTask.bind(this) }`. Then, you define the binded methods (in this case `getUserTask` and `postUserTask`), which have access to all PROCEED dependencies.

Afterwards, in your display item you can use `window.PROCEED_Data.<method>('/<DisplayItem-ID>/<Defined-API>', [<Method-Variables>] )` to communicate with the Engine and the binded, predefined methods. (Only `get` and `post` are currently allowed for `<method>`) E.g.

```
window.PROCEED_DATA.get('/tasklist/api/userTask', {
    instanceID,
    userTaskID,
    processChain,
    callChain,
  }).then( ...
```

### Styling of the Display Item

Every display item usually have its own style file.
But additionally, to achieve a somehow consistent look on all display items, we offer some general stylesheets (under `./src/display-items/<yyy>.css) which you should include in your project:

- `pure-base-min.css` from the [_PURE_ CSS framework](https://purecss.io/base/). It includes _Normalize.css_ which creates a consistent cross-browser setup. It should be included in every display item.
- `pure-grids-min.css` enables a minimal grid layout for positioning elements, if you don't want to write it on your own. [See the website for usage](https://purecss.io/grids/).
- `pure-grids-responsive-min.css` enables responsive elements in the grid layout for positioning elements, if you don't want to write it on your own. [See the website for usage](https://purecss.io/grids/#pure-responsive-grids).
- `style-buttons.css`, `style-colors.css`, `style-forms.css` are style files for buttons, colors and forms. If you want to add/use some of these elements in your display item, you should include these files.

### More Info

For further, non-technical details please take a look at the [UI module section](https://github.com/PROCEED-Labs/proceed/wiki/PROCEED-Engine-UI-Module) in the wiki.
